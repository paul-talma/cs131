# Week 2 - Lecture 1

## ML

Pattern matching

- if patterns are not exhaustive, get a partial function

Note `@` is O(n).
To avoid traversal:

```ocaml
let rev list =
    (* apprev takes in two lists a b and appends a to the reverse of b *)
    (* so here a acts as an accummulator *)
    let rec apprev a = function
        | [] -> a
        | h::t -> apprev (h :: a) t
    in
    apprev [] list;;

(*val apprev : 'a list -> 'a list -> 'a list = <fun>*)
```

## Syntax

### Desiderata

- intuitive/familiar
- unambiguous
- redundant
- extensible

### Tokenizing/Lexing

- performance issues: tokenizing is often greedy
    - this explains why you can't use _reserved_ keywords as prefixes of variables (e.g. `ifx`)

# Week 2 - Lecture 2

## Syntax

- Grammar: a spec for the syntax
- First successful programming language: FORTRAN
    - Grammar simply defined by whatever the IBM compiler supports.
    - Specs as antitrust legislation

- Second successful language: ALGOL
    - provided formal specification for the syntax
    - used context-free grammars

## Context-free grammars

Components of a context-free grammar:

- finite set of tokens (terminals)
- finite nonempty set of nonterminals
- start symbol (nonterminal)
- finite set of production rules
    - rules have form LHS -> RHS
    - LHS is a nonterminal
    - RHS is a finite (possibly empty) sequence of terminal/nonterminal symbols

> note: some versions allow infinite sets of (non)terminals

parse trees represent token sequences (the token-leaves)

- can be converted into a proof that the token sequence is a valid program
- each internal node corresponds to a grammar rule of the form `internal_node` -> `child1` `child2` ... `childn`

### Ambiguity

ambiguity corresponds to the existence of distinct proofs of the validity of a parse tree (i.e. the token string could have been generated by the application of distinct sequences of rules)

- deciding whether a grammar is ambiguous is undecidable
- fixing ambiguities as they come up is relatively easy--add new rules/nonterminals to rule out "bad" trees
- detecting ambiguities is harder (undecidable in general)

Two important sources of ambiguity:

- associativity
- precedence

### Toy C grammar

```
stmu:
    ;
    break;
    expr;
    return;
    return expr;
    goto ID;
    {stmts}
    while (expr) stmt
    for (expr_opt; expr_opt; expr_opt)
    switch (expr) stmt
    if (expr) stmu else stmt
    do stmt while (expr);
```

note that the parens around `expr` in `do while` are unnecessary, while those in `while` are necessary to resolve ambiguity.

## Notations for grammar

- `S -> aT`
- `<S> ::= a<T>`

### Internet RFC 5322

Grammar for email.
Includes a `MessageID` rule for message ids like "<eggert.$8943.fsf@cs.ucla.edu>"

```
msg-id = "<" dot-atom-text "@" id-right ">"
id-right = dot-atom-text / no-fold-literal
no-fold-literal = "[" *dtext "]"
dtext = %d33-90 / %d94-126
dot-atom-text = 1*atext *("." 1*atext)
atext = APLHA/DIGIT/"!"/"#"/"$"/.../"~"
```

`"x"` means `x` is a token
`/` means "or" (including "or"s and other metanotation takes us from BNF to extended BNF)
`*` is metanotation: zero or more occurrences of the expression
`1*` is metanotation for `+` ("1 or more")
`()` are metanotation for nesting
